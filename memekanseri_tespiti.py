# -*- coding: utf-8 -*-
"""MemeKanseri_tespiti.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/16W1nE4iU3Cq6I7RQT4qpMVqlH32XcLd2

# Verisetini drive'dan çekip düzenlendi
"""

from google.colab import drive
drive.mount('/content/drive')

import zipfile
import os

# Dosya konumunu belirttim
zip_path = "/content/drive/My Drive/archive (1).zip"
extract_path = "/content/breast_cancer_dataset"

# Zip dosyasını çıkarttım
with zipfile.ZipFile(zip_path, 'r') as zip_ref:
    zip_ref.extractall(extract_path)

print("Veri seti başarıyla çıkartıldı!")

from tensorflow.keras.preprocessing.image import ImageDataGenerator

# Eğitim ve test dizinlerinin yollarını doğru şekilde belirtim
train_dir = '/content/breast_cancer_dataset/mini/Train'
test_dir = '/content/breast_cancer_dataset/mini/Test'

# Veri artırma işlemi
train_datagen = ImageDataGenerator(
    rescale=1.0/255,  # Görüntüleri normalize et
    rotation_range=20,  # Daha düşük dönüş
    zoom_range=0.1,  # Daha düşük zoom
    horizontal_flip=True
)
test_datagen = ImageDataGenerator(rescale=1.0/255)

# Eğitim verilerini yükledim
train_generator = train_datagen.flow_from_directory(
    train_dir,
    target_size=(128, 128),  # Görüntü boyutunu ayarlayın
    batch_size=16,  # Batch boyutunu düşürme (örneğin, 16)
    class_mode='binary'
)

# Test verilerini yükledim
test_generator = test_datagen.flow_from_directory(
    test_dir,
    target_size=(128, 128),
    batch_size=16,  # Batch boyutunu düşürme (örneğin, 16)
    class_mode='binary'
)

from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.preprocessing import image
import numpy as np
import matplotlib.pyplot as plt

# Eğitim veri dizininin yolunu ayarlayın
train_dir = '/content/breast_cancer_dataset/mini/Train'

# Veri augmentasyonu
datagen = ImageDataGenerator(
    rotation_range=10,  # Görüntüleri 10 derece döndür (daha az dönüş)
    width_shift_range=0.2,  # Görüntüyü %20 oranında yatay kaydır
    height_shift_range=0.2,  # Görüntüyü %20 oranında dikey kaydır
    zoom_range=0.1,  # Görüntüyü %10 oranında yakınlaştır (daha az zoom)
    horizontal_flip=True,  # Görüntüleri yatay olarak çevir
    fill_mode='nearest'  # Yeniden boyutlandırılacak alanları doldur
)

# Eğitim verilerini yükle
train_generator = datagen.flow_from_directory(
    train_dir,
    target_size=(128, 128),  # Görüntüleri 128x128 boyutlarına getir
    batch_size=16,  # Her seferinde 32 görüntü işle
    class_mode='binary',  # İkili sınıflandırma (pozitif/negatif)
    shuffle=True  # Veriyi karıştır
)

# Augmentasyon uygulama
augmented_images, augmented_labels = next(train_generator)

# Görüntüleri uint8 formatına getir
scaled_images = augmented_images.astype(np.uint8)  # Görüntüleri doğrudan uint8'e dönüştür

# Augment edilmiş ilk 5 görüntüyü görselleştir
fig, axes = plt.subplots(1, 5, figsize=(20, 20))
for i, ax in enumerate(axes):
    ax.imshow(scaled_images[i])  # Görüntüler doğru şekilde gösterilecek
    ax.axis('off')
plt.show()

"""# CNN modeli oluşturuldu ve doğrulukları hesaplandı"""

from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Conv2D, MaxPooling2D, Flatten, Dense, Dropout

# Model oluşturma
model = Sequential([
    Conv2D(32, (3, 3), activation='relu', input_shape=(128, 128, 3)),
    MaxPooling2D((2, 2)),
    Conv2D(64, (3, 3), activation='relu'),
    MaxPooling2D((2, 2)),
    Flatten(),
    Dense(128, activation='relu'),
    Dropout(0.5),
    Dense(1, activation='sigmoid')
])

model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])

# Modeli eğitme
history = model.fit(
    train_generator,
    epochs=20,
    validation_data=test_generator
)

model.compile(
    optimizer='adam',
    loss='binary_crossentropy',
    metrics=['accuracy']
)

history = model.fit(
    train_generator,
    steps_per_epoch=len(train_generator),
    epochs=10,  # Eğitim epoch sayısını ayarlayın
    validation_data=test_generator,
    validation_steps=len(test_generator)
)

import matplotlib.pyplot as plt
from scipy.ndimage.filters import uniform_filter1d

# Yumuşatma filtresi uygulama (örneğin, hareketli ortalama)
smoothed_accuracy = uniform_filter1d(history.history['accuracy'], size=3)
smoothed_val_accuracy = uniform_filter1d(history.history['val_accuracy'], size=3)

# Doğruluk grafiği
plt.plot(history.history['accuracy'], label='Eğitim Doğruluğu')
plt.plot(history.history['val_accuracy'], label='Doğrulama Doğruluğu')
plt.xlabel('Epoch')
plt.ylabel('Doğruluk')
plt.legend()
plt.title('Doğruluk Grafiği')
plt.show()

# Kayıp grafiği
plt.plot(history.history['loss'], label='Eğitim Kaybı')
plt.plot(history.history['val_loss'], label='Doğrulama Kaybı')
plt.xlabel('Epoch')
plt.ylabel('Kayıp')
plt.legend()
plt.title('Kayıp Grafiği')
plt.show()

model.save('breast_cancer_model.h5')

from sklearn.metrics import confusion_matrix
import numpy as np
import seaborn as sns
import matplotlib.pyplot as plt

# Gerçek etiketleri al
y_true = test_generator.classes

# Tahminleri al
predictions = model.predict(test_generator)
y_pred = np.round(predictions).astype(int).flatten()

# Confusion Matrix hesapla
cm = confusion_matrix(y_true, y_pred)

# Confusion Matrix'i görselleştir
plt.figure(figsize=(6, 4))
sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=['Negative', 'Positive'], yticklabels=['Negative', 'Positive'])
plt.xlabel('Predicted Labels')
plt.ylabel('True Labels')
plt.title('Confusion Matrix')
plt.show()

# Confusion Matrix'i yazdır
print("Confusion Matrix:")
print(cm)

import matplotlib.pyplot as plt
import os
from tensorflow.keras.preprocessing.image import load_img, img_to_array

# Veri dizininin yolunu tanımlayın
data_dir = '/content/breast_cancer_dataset/mini/Train'
class_names = os.listdir(data_dir)  # 0 ve 1 sınıflarını alır

import os

data_dir = '/content/breast_cancer_dataset/mini/Train'  # Yolun doğru olduğundan emin olun
print(os.listdir(data_dir))  # Dizin içeriğini listele

import matplotlib.pyplot as plt
from tensorflow.keras.preprocessing.image import load_img
import os

# Veri dizini
data_dir = '/content/breast_cancer_dataset/mini/Train'

# Sınıf isimlerinden biri olan '00' kullanılarak ilk 5 görüntü görselleştirilir
class_name = '00'  # İlgili sınıf adı
fig, axes = plt.subplots(1, 5, figsize=(20, 10))  # 1 satır, 5 sütun

for i, image_name in enumerate(os.listdir(f"{data_dir}/{class_name}")[:5]):  # İlk 5 görüntü
    img_path = os.path.join(data_dir, class_name, image_name)
    img = load_img(img_path, target_size=(128, 128))  # Görüntüleri yükle ve yeniden boyutlandır
    axes[i].imshow(img)
    axes[i].axis('off')  # Eksenleri kaldır
    axes[i].set_title(f"{class_name} - {image_name}")

plt.tight_layout()
plt.show()

"""# VGG16 ile Özellik Çıkarımı ve PCA İle Boyut İndirgeme ile KNN Sınıflandırması"""

from sklearn.svm import SVC
from tensorflow.keras.applications import VGG16
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from sklearn.metrics import classification_report
import numpy as np

# Eğitim ve test veri yolları
train_dir = '/content/breast_cancer_dataset/mini/Train'
test_dir = '/content/breast_cancer_dataset/mini/Test'

# Görüntüleri yeniden boyutlandırma ve normalleştirme
datagen = ImageDataGenerator(rescale=1./255)
train_generator = datagen.flow_from_directory(train_dir, target_size=(128, 128), batch_size=32, class_mode='binary', shuffle=False)
test_generator = datagen.flow_from_directory(test_dir, target_size=(128, 128), batch_size=32, class_mode='binary', shuffle=False)

# VGG16 modelinden özellik çıkarma (önceden eğitilmiş model)
vgg_model = VGG16(weights='imagenet', include_top=False, input_shape=(128, 128, 3))
train_features = vgg_model.predict(train_generator)
test_features = vgg_model.predict(test_generator)

# Özellikleri tek bir vektöre dönüştürme
train_features = train_features.reshape(train_features.shape[0], -1)
test_features = test_features.reshape(test_features.shape[0], -1)

# SVM ile sınıflandırma
svm_model = SVC(kernel='rbf', C=1, gamma='scale')
svm_model.fit(train_features, train_generator.classes)

# Test doğruluğunu değerlendirme
predictions = svm_model.predict(test_features)
print(classification_report(test_generator.classes, predictions))

import matplotlib.pyplot as plt
from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay, accuracy_score

# Eğitim ve test doğruluklarını hesaplayın
train_accuracy = svm_model.score(train_features, train_generator.classes)
test_accuracy = accuracy_score(test_generator.classes, predictions)

# Eğitim ve test doğruluğunu görselleştirme
plt.figure(figsize=(6, 4))
plt.bar(["Eğitim Doğruluğu", "Test Doğruluğu"], [train_accuracy, test_accuracy], color=['blue', 'red'])
plt.title("Eğitim ve Test Doğrulukları")
plt.ylabel("Doğruluk")
plt.ylim(0, 1)
plt.show()

# Confusion Matrix Görselleştirme
cm = confusion_matrix(test_generator.classes, predictions)
disp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=["Sınıf 0", "Sınıf 1"])
disp.plot(cmap='Blues')
plt.title("Confusion Matrix")
plt.show()

# Etiketleri dönüştürme (11 -> 1, 0 -> 0)
train_labels = np.where(train_labels == 11, 1, train_labels)

"""# Segmentasyon Yapıldı"""

import numpy as np
import os
import cv2
import matplotlib.pyplot as plt
from tensorflow.keras.models import Model
from tensorflow.keras.layers import Input, Conv2D, MaxPooling2D, Flatten, Dense
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from sklearn.model_selection import train_test_split

# Modeli tanımlama (sınıflandırma için U-Net modifikasyonu)
def unet_classification_model(input_size=(64, 64, 3)):
    inputs = Input(input_size)

    # Down-sampling (Encoder)
    c1 = Conv2D(32, (3, 3), activation='relu', padding='same')(inputs)
    c1 = Conv2D(32, (3, 3), activation='relu', padding='same')(c1)
    p1 = MaxPooling2D((2, 2))(c1)

    c2 = Conv2D(64, (3, 3), activation='relu', padding='same')(p1)
    c2 = Conv2D(64, (3, 3), activation='relu', padding='same')(c2)
    p2 = MaxPooling2D((2, 2))(c2)

    c3 = Conv2D(128, (3, 3), activation='relu', padding='same')(p2)
    c3 = Conv2D(128, (3, 3), activation='relu', padding='same')(c3)
    p3 = MaxPooling2D((2, 2))(c3)

    # Bottleneck
    c4 = Conv2D(256, (3, 3), activation='relu', padding='same')(p3)
    c4 = Conv2D(256, (3, 3), activation='relu', padding='same')(c4)

    # Flatten ve fully connected katmanlar
    flat = Flatten()(c4)
    dense1 = Dense(128, activation='relu')(flat)
    dense2 = Dense(1, activation='sigmoid')(dense1)  # Çıktı katmanı: 0 veya 1

    model = Model(inputs=[inputs], outputs=[dense2])
    return model

# Modelin oluşturulması
unet_class = unet_classification_model()
unet_class.compile(optimizer=Adam(learning_rate=1e-5), loss='binary_crossentropy', metrics=['accuracy'])

# Veri hazırlığı (görüntüler ve etiketler)
train_dir = '/content/breast_cancer_dataset/mini/Train'  # Görsellerin bulunduğu üst dizin
img_size = (64, 64)  # Görüntü boyutunu küçültüyoruz

# Veri yükleme fonksiyonu
def load_data_and_labels_from_folders(base_dir, img_size=(64, 64)):
    images, labels = [], []
    for folder_name in os.listdir(base_dir):
        folder_path = os.path.join(base_dir, folder_name)
        if os.path.isdir(folder_path):
            if folder_name == '00':  # '00' klasörünü 0 etiketiyle eşle
                label = 0
            elif folder_name == '11':  # '11' klasörünü 1 etiketiyle eşle
                label = 1
            else:
                continue  # Farklı bir klasör varsa atla

            for img_name in os.listdir(folder_path):
                if img_name.endswith('.png'):
                    img_path = os.path.join(folder_path, img_name)
                    img = cv2.imread(img_path)
                    if img is not None:
                        img = cv2.resize(img, img_size)
                        images.append(img / 255.0)
                        labels.append(label)
    return np.array(images), np.array(labels)


# Eğitim verilerini yükleme
train_images, train_labels = load_data_and_labels_from_folders(train_dir, img_size)

# Eğitim ve doğrulama verisi için veri artırma
datagen = ImageDataGenerator(
    rotation_range=20,
    width_shift_range=0.2,
    height_shift_range=0.2,
    shear_range=0.2,
    zoom_range=0.2,
    horizontal_flip=True,
    fill_mode='nearest'
)

# Eğitim ve doğrulama setlerini ayırma (validation_split yerine burada manuel ayırıyoruz)
train_images, val_images, train_labels, val_labels = train_test_split(
    train_images, train_labels, test_size=0.2, random_state=42)

# Modeli eğitme
history = unet_class.fit(datagen.flow(train_images, train_labels, batch_size=16),
                         validation_data=(val_images, val_labels), epochs=10)

# Eğitim sonuçlarını görselleştirme
plt.plot(history.history['accuracy'], label='Eğitim Doğruluğu')
plt.plot(history.history['val_accuracy'], label='Doğrulama Doğruluğu')
plt.legend()
plt.show()

# Eğitim kaybı ve doğruluğu görselleştirme
plt.plot(history.history['loss'], label='Eğitim Kaybı')
plt.plot(history.history['val_loss'], label='Doğrulama Kaybı')
plt.legend()
plt.show()

import numpy as np
import matplotlib.pyplot as plt
from sklearn.metrics import confusion_matrix, ConfusionMatrixDisplay

# Confusion Matrix için fonksiyon
def plot_confusion_matrix(model, val_images, val_labels):
    # Modeli kullanarak tahminler yapıyoruz
    val_predictions = (model.predict(val_images) > 0.5).astype("int32")  # 0.5 eşiğini kullanarak sınıflandırma

    # Confusion Matrix hesaplama
    cm = confusion_matrix(val_labels, val_predictions)

    # Confusion Matrix görüntüleme
    disp = ConfusionMatrixDisplay(confusion_matrix=cm, display_labels=[0, 1])
    disp.plot(cmap='Blues')
    plt.title('Confusion Matrix')
    plt.show()

# Confusion Matrix'i görselleştirme
plot_confusion_matrix(unet_class, val_images, val_labels)

"""# VGG16 ile Özellik Çıkarımı ve PCA İle Boyut İndirgeme ile KNN Sınıflandırması"""

import numpy as np
import matplotlib.pyplot as plt
from sklearn.decomposition import PCA
from sklearn.neighbors import KNeighborsClassifier
from sklearn.metrics import classification_report
from tensorflow.keras.preprocessing.image import ImageDataGenerator
from tensorflow.keras.applications import VGG16
from tensorflow.keras.models import Sequential

# Eğitim ve test veri yolları
train_dir = '/content/breast_cancer_dataset/mini/Train'
test_dir = '/content/breast_cancer_dataset/mini/Test'

# Görüntüleri yeniden boyutlandırma ve normalleştirme
datagen = ImageDataGenerator(rescale=1./255)

train_generator = datagen.flow_from_directory(
    train_dir,
    target_size=(128, 128),
    batch_size=32,
    class_mode='binary',
    shuffle=False
)

test_generator = datagen.flow_from_directory(
    test_dir,
    target_size=(128, 128),
    batch_size=32,
    class_mode='binary',
    shuffle=False
)

# VGG16 modelinden özellik çıkarımı (önceden eğitilmiş model)
vgg_model = VGG16(weights='imagenet', include_top=False, input_shape=(128, 128, 3))

# Özellik çıkarımı
train_features = vgg_model.predict(train_generator)
test_features = vgg_model.predict(test_generator)

# Özellikleri tek bir vektöre dönüştürme
train_features = train_features.reshape(train_features.shape[0], -1)
test_features = test_features.reshape(test_features.shape[0], -1)

# PCA ile boyut indirgeme
pca = PCA(n_components=100)  # 100 bileşenli özelliğe indirgeme
train_features_pca = pca.fit_transform(train_features)
test_features_pca = pca.transform(test_features)

# KNN ile sınıflandırma
knn_model = KNeighborsClassifier(n_neighbors=3, algorithm='ball_tree')
knn_model.fit(train_features_pca, train_generator.classes)

# Test doğruluğunu değerlendirme
predictions = knn_model.predict(test_features_pca)
print(classification_report(test_generator.classes, predictions))

# Doğruluk ve Kayıp Grafikleri


# Sınıflandırma raporu
predictions = knn_model.predict(test_features_pca)
print(classification_report(test_generator.classes, predictions))